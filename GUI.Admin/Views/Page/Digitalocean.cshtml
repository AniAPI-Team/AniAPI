@section Styles {
    <style>
    </style>
}

<div class="row">
    <div class="col-md-11 mb-4">
        <h6>Droplet</h6>
        <select class="form-select" aria-label="Droplet" id="droplet" onchange="onDropletChange()"></select>
    </div>
    <div class="col-md-1 mb-4 d-flex justify-content-center align-items-center" id="loader">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
</div>
<div class="row">
    <div class="col-md-3">
        <div class="box p-3">
            <h6>vCPUs</h6>
            <span id="droplet-cpu"></span>
        </div>
    </div>
    <div class="col-md-3">
        <div class="box p-3">
            <h6>Memory</h6>
            <span id="droplet-memory"></span>
        </div>
    </div>
    <div class="col-md-3">
        <div class="box p-3">
            <h6>Disk</h6>
            <span id="droplet-disk"></span>
        </div>
    </div>
    <div class="col-md-3">
        <div class="box p-3">
            <h6>Status</h6>
            <span class="badge rounded-pill" id="droplet-status"></span>
        </div>
    </div>
</div>
<div class="row">
    <div class="col-md-6">
        <div class="box p-3">
            <h6>Inbound bandwidth</h6>
            <div class="position-relative" style="height:300px;width:100%;margin-bottom:1rem">
                <canvas id="chart-inbound-bandwidth"></canvas>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="box p-3">
            <h6>Outbound bandwidth</h6>
            <div class="position-relative" style="height:300px;width:100%;margin-bottom:1rem">
                <canvas id="chart-outbound-bandwidth"></canvas>
            </div>
        </div>
    </div>
</div>
<div class="row">
    <div class="col-md-6">
        <div class="box p-3">
            <h6>CPU usage</h6>
            <div class="position-relative" style="height:300px;width:100%;margin-bottom:1rem">
                <canvas id="chart-cpu"></canvas>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="box p-3">
            <h6>Memory usage</h6>
            <div class="position-relative" style="height:300px;width:100%;margin-bottom:1rem">
                <canvas id="chart-memory"></canvas>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const _token = '56b584d634380007f4e7b8f1e36ff8ed689c497dac51bcc3b5c230fef6532082';
        const _droplets = [];

        var _bandwidthCharts = {};
        var _cpuChart, _memoryChart;

        document.addEventListener('DOMContentLoaded', async () => {
            await loadDroplets();

            pageLoaded();
        });

        window.addEventListener('resize', () => {
            resizeChart();
        });

        const onToggleCollapse = (size) => {
            resizeChart(size);
        }

        const resizeChart = (size) => {
            if (!size) {
                size = document.querySelector('#root .sidebar').clientWidth;
            }
        
            const w = window.innerWidth - size - 42 * 2;
            const _60p = ((w - 12 * 4) * 60) / 120;

            for (let chart in _bandwidthCharts) {
                _bandwidthCharts[chart].canvas.parentNode.style.width = `${_60p}px`;
            }

            _cpuChart.canvas.parentNode.style.width = `${_60p}px`;
            _memoryChart.canvas.parentNode.style.width = `${_60p}px`;
        }

        const onDropletChange = async () => {
            document.getElementById('loader').style.visibility = 'visible';

            const value = document.getElementById('droplet').value;
            const droplet = _droplets.find(x => x.id == value);

            document.getElementById('droplet-cpu').innerText = droplet.cpu;
            document.getElementById('droplet-memory').innerText = `${droplet.memory} MB`;
            document.getElementById('droplet-disk').innerText = `${droplet.disk} GB`;

            document.getElementById('droplet-status').classList.remove('bg-success');
            document.getElementById('droplet-status').classList.remove('bg-danger');

            if (droplet.status === 'active') {
                document.getElementById('droplet-status').classList.add('bg-success');
            }
            else {
                document.getElementById('droplet-status').classList.add('bg-danger');
            }

            document.getElementById('droplet-status').innerText = droplet.status;

            await loadBandwidthCharts(droplet.id);
            await loadCPUChart(droplet.id);
            await loadMemoryChart(droplet.id);

            document.getElementById('loader').style.visibility = 'hidden';
        }

        const loadDroplets = async () => {
            const req = await fetch('https://api.digitalocean.com/v2/droplets?tag_name=aniapi', {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${_token}`
                }
            });
            const res = await req.json();

            for (let i = 0; i < res.droplets.length; i++) {
                const droplet = res.droplets[i]; 

                const option = document.createElement('option');
                option.value = droplet.id;
                option.innerText = droplet.name;

                document.getElementById('droplet').appendChild(option);

                _droplets.push({
                    id: droplet.id,
                    cpu: droplet.vcpus,
                    memory: droplet.memory,
                    disk: droplet.disk,
                    status: droplet.status
                });
            }

            onDropletChange();
        }

        const loadBandwidthCharts = async (hostId) => {
            const types = [
                'inbound',
                'outbound'
            ];
            const colors = [
                '#80CBC4',
                '#26A69A'
            ];

            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 7);

            for (let i = 0; i < types.length; i++) {
                const type = types[i];

                const url = `https://api.digitalocean.com/v2/monitoring/metrics/droplet/bandwidth?host_id=${hostId}&interface=public&direction=${type}&start=${getCurrentTimestamp(start)}&end=${getCurrentTimestamp(end)}`;
                const req = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${_token}`
                    }
                });
                const res = await req.json();

                if (res.data) {
                    let labels = [];
                    let dataset = {
                        label: 'Mb/s',
                        backgroundColor: colors[i],
                        borderColor: colors[i],
                        pointRadius: 0,
                        fill: true,
                        data: []
                    };

                    const array = res.data.result[0].values;

                    for (let j = 0; j < array.length; j++) {
                        labels.push(formatTime(new Date(array[j][0] * 1000)));
                        dataset.data.push(parseFloat(array[j][1]).toFixed(2).replace(',', '.'));
                    }

                    const data = {
                        labels: labels,
                        datasets: [dataset]
                    };

                    const config = {
                        type: 'line',
                        data: data,
                        options: {
                            maintainAspectRatio: false,
                            responsive: true,
                            hover: {
                                mode: 'nearest',
                                intersect: true
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        stepSize: 1,
                                        maxRotation: 0,
                                        minRotation: 0,
                                        min: 0,
                                        max: 12,
                                        maxTicksLimit: 13,
                                        callback: function (value, index, values) {
                                            return this.getLabelForValue(value).split(' ')[0].replace(`${new Date().getFullYear()}-`, '');
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            }
                        }
                    };

                    if (_bandwidthCharts[type]) {
                        _bandwidthCharts[type].destroy();
                    }

                    _bandwidthCharts[type] = new Chart(document.getElementById(`chart-${type}-bandwidth`), config);
                }
            }
        }

        const loadCPUChart = async (hostId) => {
            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 7);

            const url = `https://api.digitalocean.com/v2/monitoring/metrics/droplet/cpu?host_id=${hostId}&start=${getCurrentTimestamp(start)}&end=${getCurrentTimestamp(end)}`;
            const req = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${_token}`
                }
            });
            const res = await req.json();

            if (res.data) {
                let labels = [];
                let dataset = {
                    label: 'Used',
                    backgroundColor: '#5C6BC0',
                    borderColor: '#5C6BC0',
                    pointRadius: 0,
                    fill: true,
                    data: []
                };

                const array = res.data.result[7].values;

                for (let j = 1; j < array.length; j++) {
                    const prevIdle = parseFloat(res.data.result[0].values[j - 1][1]) + parseFloat(res.data.result[1].values[j - 1][1]);
                    let prevNoIdle = 0;

                    for (let k = 2; k < 8; k++) {
                        prevNoIdle += parseFloat(res.data.result[k].values[j - 1][1]);
                    }

                    const idle = parseFloat(res.data.result[0].values[j][1]) + parseFloat(res.data.result[1].values[j][1]);
                    let noIdle = 0;

                    for (let k = 2; k < 8; k++) {
                        noIdle += parseFloat(res.data.result[k].values[j][1]);
                    }

                    const prevTotal = prevIdle + prevNoIdle;
                    const total = idle + noIdle;

                    const totalDelta = total - prevTotal;
                    const idleDelta = idle - prevIdle;

                    const p = (((totalDelta - idleDelta) / totalDelta) * 100).toFixed(2).replace(',', '.');

                    labels.push(formatTime(new Date(array[j][0] * 1000)));
                    dataset.data.push(p);
                }

                const data = {
                    labels: labels,
                    datasets: [dataset]
                };

                const config = {
                    type: 'line',
                    data: data,
                    options: {
                        maintainAspectRatio: false,
                        responsive: true,
                        hover: {
                            mode: 'nearest',
                            intersect: true
                        },
                        scales: {
                            x: {
                                ticks: {
                                    stepSize: 1,
                                    maxRotation: 0,
                                    minRotation: 0,
                                    min: 0,
                                    max: 12,
                                    maxTicksLimit: 13,
                                    callback: function (value, index, values) {
                                        return this.getLabelForValue(value).split(' ')[0].replace(`${new Date().getFullYear()}-`, '');
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (ctx) => {
                                        return `${ctx.dataset.label}: ${ctx.parsed.y} %`;
                                    }
                                }
                            }
                        }
                    }
                };

                if (_cpuChart) {
                    _cpuChart.destroy();
                }

                _cpuChart = new Chart(document.getElementById('chart-cpu'), config);
            }
        }

        const loadMemoryChart = async (hostId) => {
            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 7);

            const url = `https://api.digitalocean.com/v2/monitoring/metrics/droplet/memory_available?host_id=${hostId}&start=${getCurrentTimestamp(start)}&end=${getCurrentTimestamp(end)}`;
            const req = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${_token}`
                }
            });
            const res = await req.json();

            const total = await getMemoryTotal(hostId);

            if (res.data) {
                let labels = [];
                let dataset = {
                    label: 'Used',
                    backgroundColor: '#29B6F6',
                    borderColor: '#29B6F6',
                    pointRadius: 0,
                    fill: true,
                    data: []
                };

                const array = res.data.result[0].values;

                for (let j = 0; j < array.length; j++) {
                    const available = parseInt(array[j][1]);

                    if (available > total) {
                        continue;
                    }

                    labels.push(formatTime(new Date(array[j][0] * 1000)));

                    const used = total - available;
                    const p = (used * 100) / total;

                    dataset.data.push(p.toFixed(2).replace(',', '.'));
                }

                const data = {
                    labels: labels,
                    datasets: [dataset]
                };

                const config = {
                    type: 'line',
                    data: data,
                    options: {
                        maintainAspectRatio: false,
                        responsive: true,
                        hover: {
                            mode: 'nearest',
                            intersect: true
                        },
                        scales: {
                            x: {
                                ticks: {
                                    stepSize: 1,
                                    maxRotation: 0,
                                    minRotation: 0,
                                    min: 0,
                                    max: 12,
                                    maxTicksLimit: 13,
                                    callback: function (value, index, values) {
                                        return this.getLabelForValue(value).split(' ')[0].replace(`${new Date().getFullYear()}-`, '');
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (ctx) => {
                                        return `${ctx.dataset.label}: ${ctx.parsed.y} %`;
                                    }
                                }
                            }
                        }
                    }
                };

                if (_memoryChart) {
                    _memoryChart.destroy();
                }

                _memoryChart = new Chart(document.getElementById('chart-memory'), config);
            }
        }

        const getMemoryTotal = async (hostId) => {
            const end = new Date();
            const start = new Date();
            start.setSeconds(end.getSeconds() - 1);

            const url = `https://api.digitalocean.com/v2/monitoring/metrics/droplet/memory_total?host_id=${hostId}&start=${getCurrentTimestamp(start)}&end=${getCurrentTimestamp(end)}`;
            const req = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${_token}`
                }
            });
            const res = await req.json();

            return parseInt(res.data.result[0].values[0][1]);
        }
    </script>
}